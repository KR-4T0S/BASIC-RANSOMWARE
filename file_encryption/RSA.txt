"""
@author: Team PEMDAS
"""
import os.path
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import padding, hmac, hashes

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa

# Global Constants
CONST_LEN_KEY = 32
CONST_LEN_IV = 16
CONST_LEN_BLOCK = 128
CONST_PUBLIC_EXPONENT = 65537
CONST_KEY_LENGTH = 2048
CONST_KEY_PUBLIC_PATH = "rsa_key_public.pem"
CONST_KEY_PRIVATE_PATH = "rsa_key_private.pem"

def main():
    if not haskeys():
        keygen()

def haskeys():
    # Check for rsa_key_public.pem and rsa_key_private.pem in program root dir
    if not os.path.isfile(CONST_KEY_PRIVATE_PATH) or not os.path.isfile(CONST_KEY_PUBLIC_PATH):
        print("Missing keys.")
        return False
    else:
        print("Public and Private keys exist.")
        return True

def keygen(): 
    #################
    ## PRIVATE KEY ##
    #################
    # Generate new RSA private key with given backend, e, and key size.
    key_private = rsa.generate_private_key(
        public_exponent = CONST_PUBLIC_EXPONENT,
        key_size = CONST_KEY_LENGTH,
        backend = default_backend()
    )
    
    # Serialize private key without encryption.
    pem_private = key_private.private_bytes(
        encoding = serialization.Encoding.PEM, 
        format = serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm = serialization.NoEncryption()
    )
    
    # Write serialized key into file
    with open(CONST_KEY_PRIVATE_PATH, 'wb') as file:
        file.write(pem_private)
    
    ################
    ## PUBLIC KEY ##
    ################
    # Generate new RSA public key using private key.
    key_public = key_private.public_key()
    
    # Serialize public key
    pem_public = key_public.public_bytes(
        encoding = serialization.Encoding.PEM,
        format = serialization.PublicFormat.SubjectPublicKeyInfo
    )
    
    # Write serialized key into file
    with open(CONST_KEY_PUBLIC_PATH, 'wb') as file:
        file.write(pem_public)

def MyfileEncrypt(filepath):
    # Generate Key and IV
    key = os.urandom(CONST_LEN_KEY)
    HMACKey = os.urandom(CONST_LEN_KEY)
    
    # Get file extension
    name, ext = os.path.splitext(filepath)
    
    # Open File
    mode = "rb" # Set to read bits
    with open(filepath, mode) as file:
        M = file.read()
        file.close()
    
    # Encrypt string file data
    C, IV, tag = Myencrypt(M, key, HMACKey)
    
    return (C, IV, tag, key, HMACKey, ext)

def Myencrypt(message, key, HMACKey):
    # Prompt error if key < 32 bytes
    if len(key) < CONST_LEN_KEY:
        print("[!] Error. Key must be 32 bytes. Try again. [!]")
        return None, None
    else:
        # Generate random 16 Bytes IV
        IV = os.urandom(CONST_LEN_IV)
        
        # Padding for CBC
        padder = padding.PKCS7(CONST_LEN_BLOCK).padder()
        paddedMessage = padder.update(message) + padder.finalize()
        
        # Start cipher with key and IV
        cipher = Cipher(algorithms.AES(key), 
                        modes.CBC(IV), 
                        default_backend())
        encryptor = cipher.encryptor()
        C = encryptor.update(paddedMessage) + encryptor.finalize()
        
        # Generate tag from HMAC key and using SHA256
        tag = hmac.HMAC(HMACKey,
                  hashes.SHA256(), 
                  default_backend())
        tag.update(C)
        tag = tag.finalize()
        
        return (C, IV, tag)


def Mydecrypt(C, IV, tag, key, HMACKey):
    # Prompt error if key < 32 bytes
    if len(key) < CONST_LEN_KEY:
        print("[!] Error. Key must be 32 bytes. Try again. [!]")
        return None
    else:
        # Tag check using SHA256
        tagCheck = hmac.HMAC(HMACKey, 
                             hashes.SHA256(), 
                             default_backend())
        tagCheck.update(C)
        tagCheck.verify(tag)
        
        # Start cipher with key and IV
        cipher = Cipher(algorithms.AES(key), 
                        modes.CBC(IV), 
                        default_backend())
        
        # Decrypt
        decryptor = cipher.decryptor()
        paddedMessage = decryptor.update(C) + decryptor.finalize()
        
        # Unpad the decrypted bytes
        unpadder = padding.PKCS7(CONST_LEN_BLOCK).unpadder()
        M = unpadder.update(paddedMessage) + unpadder.finalize()
        
        return (M)

def MyfileDecrypt(C, IV, tag, key, HMACKey, ext):
    # Call encryption for entire message, CBC does block cipher on its own.
    M = Mydecrypt(C, IV, tag, key, HMACKey)
    
    # Temp file name and string
    newFile = "temp" + ext
    
    # Write file
    mode = "wb" # Set to read bits
    with open(newFile, mode) as file:
        file.write(M)
        file.close()


def MyRSAEncrypt(filepath, CONST_KEY_PUBLIC_PATH):
  C, IV, tag, Enckey, HMACkey, ext = MyFileEncryptMAC(filepath)
  RSApublickey = rsa.generate_publickey(pem_public)
  key = Enckey + HMACkey
  RSACipher = RSApublickey.encrypt(
    key, 
    padding.OAEP(
      mgf=padding.MGF1(algorithm=hashes.SHA256()),
      algorithm=hashes.SHA256(),
      label=None
      )
    )
    return (RSACipher, C, IV, tag, ext)

def MyRSADecrypt(RSACipher, C, IV, ext, CONST_KEY_PRIVATE_PATH):
  RSAprivatekey = rsa.generate_privatekey(pem_private)
  key = private_key.decrypt(
    RSACipher,
    padding.OAEP(
      mgf=padding.MGF1(algorithm=hashes.SHA256()),
      algorithm=hashes.SHA256(),
      label=None
      )
    )
  Enckey, HMACkey = key[:len(key)/2], key[len(key)/2:]
  filepath = MyfileDecrypt(C, IV, tag, Enckey, HMACKey, ext)
  return filepath

if __name__ == "__main__": main()